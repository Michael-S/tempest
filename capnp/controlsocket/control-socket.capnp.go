// Code generated by capnpc-go. DO NOT EDIT.

package controlsocket

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	fmt "fmt"
	util "zenhack.net/go/sandstorm/capnp/util"
)

// Constants defined in control-socket.capnp.
const (
	Controller_socketPath = "/var/sandstorm/socket/control"
)

type Controller capnp.Client

// Controller_TypeID is the unique identifier for the type Controller.
const Controller_TypeID = 0xd2279138704f4cad

func (c Controller) DevShell(ctx context.Context, params func(Controller_devShell_Params) error) (Controller_devShell_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xd2279138704f4cad,
			MethodID:      0,
			InterfaceName: "control-socket.capnp:Controller",
			MethodName:    "devShell",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Controller_devShell_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Controller_devShell_Results_Future{Future: ans.Future()}, release
}
func (c Controller) Dev(ctx context.Context, params func(Controller_dev_Params) error) (Controller_dev_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xd2279138704f4cad,
			MethodID:      1,
			InterfaceName: "control-socket.capnp:Controller",
			MethodName:    "dev",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Controller_dev_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Controller_dev_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Controller) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Controller) AddRef() Controller {
	return Controller(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Controller) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Controller) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Controller) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Controller) DecodeFromPtr(p capnp.Ptr) Controller {
	return Controller(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Controller) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Controller) IsSame(other Controller) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Controller) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Controller) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A Controller_Server is a Controller with a local implementation.
type Controller_Server interface {
	DevShell(context.Context, Controller_devShell) error

	Dev(context.Context, Controller_dev) error
}

// Controller_NewServer creates a new Server from an implementation of Controller_Server.
func Controller_NewServer(s Controller_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Controller_Methods(nil, s), s, c)
}

// Controller_ServerToClient creates a new Client from an implementation of Controller_Server.
// The caller is responsible for calling Release on the returned Client.
func Controller_ServerToClient(s Controller_Server) Controller {
	return Controller(capnp.NewClient(Controller_NewServer(s)))
}

// Controller_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Controller_Methods(methods []server.Method, s Controller_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xd2279138704f4cad,
			MethodID:      0,
			InterfaceName: "control-socket.capnp:Controller",
			MethodName:    "devShell",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.DevShell(ctx, Controller_devShell{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xd2279138704f4cad,
			MethodID:      1,
			InterfaceName: "control-socket.capnp:Controller",
			MethodName:    "dev",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Dev(ctx, Controller_dev{call})
		},
	})

	return methods
}

// Controller_devShell holds the state for a server call to Controller.devShell.
// See server.Call for documentation.
type Controller_devShell struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Controller_devShell) Args() Controller_devShell_Params {
	return Controller_devShell_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Controller_devShell) AllocResults() (Controller_devShell_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Controller_devShell_Results(r), err
}

// Controller_dev holds the state for a server call to Controller.dev.
// See server.Call for documentation.
type Controller_dev struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Controller_dev) Args() Controller_dev_Params {
	return Controller_dev_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Controller_dev) AllocResults() (Controller_dev_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Controller_dev_Results(r), err
}

// Controller_List is a list of Controller.
type Controller_List = capnp.CapList[Controller]

// NewController creates a new list of Controller.
func NewController_List(s *capnp.Segment, sz int32) (Controller_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Controller](l), err
}

type Controller_devShell_Params capnp.Struct

// Controller_devShell_Params_TypeID is the unique identifier for the type Controller_devShell_Params.
const Controller_devShell_Params_TypeID = 0x9780c0aba70a923b

func NewController_devShell_Params(s *capnp.Segment) (Controller_devShell_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Controller_devShell_Params(st), err
}

func NewRootController_devShell_Params(s *capnp.Segment) (Controller_devShell_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Controller_devShell_Params(st), err
}

func ReadRootController_devShell_Params(msg *capnp.Message) (Controller_devShell_Params, error) {
	root, err := msg.Root()
	return Controller_devShell_Params(root.Struct()), err
}

func (s Controller_devShell_Params) String() string {
	str, _ := text.Marshal(0x9780c0aba70a923b, capnp.Struct(s))
	return str
}

func (s Controller_devShell_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Controller_devShell_Params) DecodeFromPtr(p capnp.Ptr) Controller_devShell_Params {
	return Controller_devShell_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Controller_devShell_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Controller_devShell_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Controller_devShell_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Controller_devShell_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Controller_devShell_Params_List is a list of Controller_devShell_Params.
type Controller_devShell_Params_List = capnp.StructList[Controller_devShell_Params]

// NewController_devShell_Params creates a new list of Controller_devShell_Params.
func NewController_devShell_Params_List(s *capnp.Segment, sz int32) (Controller_devShell_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Controller_devShell_Params](l), err
}

// Controller_devShell_Params_Future is a wrapper for a Controller_devShell_Params promised by a client call.
type Controller_devShell_Params_Future struct{ *capnp.Future }

func (f Controller_devShell_Params_Future) Struct() (Controller_devShell_Params, error) {
	p, err := f.Future.Ptr()
	return Controller_devShell_Params(p.Struct()), err
}

type Controller_devShell_Results capnp.Struct

// Controller_devShell_Results_TypeID is the unique identifier for the type Controller_devShell_Results.
const Controller_devShell_Results_TypeID = 0xc98eacc122f91e21

func NewController_devShell_Results(s *capnp.Segment) (Controller_devShell_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Controller_devShell_Results(st), err
}

func NewRootController_devShell_Results(s *capnp.Segment) (Controller_devShell_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Controller_devShell_Results(st), err
}

func ReadRootController_devShell_Results(msg *capnp.Message) (Controller_devShell_Results, error) {
	root, err := msg.Root()
	return Controller_devShell_Results(root.Struct()), err
}

func (s Controller_devShell_Results) String() string {
	str, _ := text.Marshal(0xc98eacc122f91e21, capnp.Struct(s))
	return str
}

func (s Controller_devShell_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Controller_devShell_Results) DecodeFromPtr(p capnp.Ptr) Controller_devShell_Results {
	return Controller_devShell_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Controller_devShell_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Controller_devShell_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Controller_devShell_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Controller_devShell_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Controller_devShell_Results) ShellFds() (ShellFDs, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return ShellFDs(p.Struct()), err
}

func (s Controller_devShell_Results) HasShellFds() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Controller_devShell_Results) SetShellFds(v ShellFDs) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewShellFds sets the shellFds field to a newly
// allocated ShellFDs struct, preferring placement in s's segment.
func (s Controller_devShell_Results) NewShellFds() (ShellFDs, error) {
	ss, err := NewShellFDs(capnp.Struct(s).Segment())
	if err != nil {
		return ShellFDs{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Controller_devShell_Results) Handle() util.Handle {
	p, _ := capnp.Struct(s).Ptr(1)
	return util.Handle(p.Interface().Client())
}

func (s Controller_devShell_Results) HasHandle() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Controller_devShell_Results) SetHandle(v util.Handle) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

// Controller_devShell_Results_List is a list of Controller_devShell_Results.
type Controller_devShell_Results_List = capnp.StructList[Controller_devShell_Results]

// NewController_devShell_Results creates a new list of Controller_devShell_Results.
func NewController_devShell_Results_List(s *capnp.Segment, sz int32) (Controller_devShell_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Controller_devShell_Results](l), err
}

// Controller_devShell_Results_Future is a wrapper for a Controller_devShell_Results promised by a client call.
type Controller_devShell_Results_Future struct{ *capnp.Future }

func (f Controller_devShell_Results_Future) Struct() (Controller_devShell_Results, error) {
	p, err := f.Future.Ptr()
	return Controller_devShell_Results(p.Struct()), err
}
func (p Controller_devShell_Results_Future) ShellFds() ShellFDs_Future {
	return ShellFDs_Future{Future: p.Future.Field(0, nil)}
}
func (p Controller_devShell_Results_Future) Handle() util.Handle {
	return util.Handle(p.Future.Field(1, nil).Client())
}

type Controller_dev_Params capnp.Struct

// Controller_dev_Params_TypeID is the unique identifier for the type Controller_dev_Params.
const Controller_dev_Params_TypeID = 0xaf8f237f68a73560

func NewController_dev_Params(s *capnp.Segment) (Controller_dev_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Controller_dev_Params(st), err
}

func NewRootController_dev_Params(s *capnp.Segment) (Controller_dev_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Controller_dev_Params(st), err
}

func ReadRootController_dev_Params(msg *capnp.Message) (Controller_dev_Params, error) {
	root, err := msg.Root()
	return Controller_dev_Params(root.Struct()), err
}

func (s Controller_dev_Params) String() string {
	str, _ := text.Marshal(0xaf8f237f68a73560, capnp.Struct(s))
	return str
}

func (s Controller_dev_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Controller_dev_Params) DecodeFromPtr(p capnp.Ptr) Controller_dev_Params {
	return Controller_dev_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Controller_dev_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Controller_dev_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Controller_dev_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Controller_dev_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Controller_dev_Params) AppId() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Controller_dev_Params) HasAppId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Controller_dev_Params) AppIdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Controller_dev_Params) SetAppId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Controller_dev_Params_List is a list of Controller_dev_Params.
type Controller_dev_Params_List = capnp.StructList[Controller_dev_Params]

// NewController_dev_Params creates a new list of Controller_dev_Params.
func NewController_dev_Params_List(s *capnp.Segment, sz int32) (Controller_dev_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Controller_dev_Params](l), err
}

// Controller_dev_Params_Future is a wrapper for a Controller_dev_Params promised by a client call.
type Controller_dev_Params_Future struct{ *capnp.Future }

func (f Controller_dev_Params_Future) Struct() (Controller_dev_Params, error) {
	p, err := f.Future.Ptr()
	return Controller_dev_Params(p.Struct()), err
}

type Controller_dev_Results capnp.Struct

// Controller_dev_Results_TypeID is the unique identifier for the type Controller_dev_Results.
const Controller_dev_Results_TypeID = 0xd4a47427f5ca501b

func NewController_dev_Results(s *capnp.Segment) (Controller_dev_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Controller_dev_Results(st), err
}

func NewRootController_dev_Results(s *capnp.Segment) (Controller_dev_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Controller_dev_Results(st), err
}

func ReadRootController_dev_Results(msg *capnp.Message) (Controller_dev_Results, error) {
	root, err := msg.Root()
	return Controller_dev_Results(root.Struct()), err
}

func (s Controller_dev_Results) String() string {
	str, _ := text.Marshal(0xd4a47427f5ca501b, capnp.Struct(s))
	return str
}

func (s Controller_dev_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Controller_dev_Results) DecodeFromPtr(p capnp.Ptr) Controller_dev_Results {
	return Controller_dev_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Controller_dev_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Controller_dev_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Controller_dev_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Controller_dev_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Controller_dev_Results) FuseFd() FileDescriptor {
	p, _ := capnp.Struct(s).Ptr(0)
	return FileDescriptor(p.Interface().Client())
}

func (s Controller_dev_Results) HasFuseFd() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Controller_dev_Results) SetFuseFd(v FileDescriptor) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s Controller_dev_Results) Session() DevSession {
	p, _ := capnp.Struct(s).Ptr(1)
	return DevSession(p.Interface().Client())
}

func (s Controller_dev_Results) HasSession() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Controller_dev_Results) SetSession(v DevSession) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

// Controller_dev_Results_List is a list of Controller_dev_Results.
type Controller_dev_Results_List = capnp.StructList[Controller_dev_Results]

// NewController_dev_Results creates a new list of Controller_dev_Results.
func NewController_dev_Results_List(s *capnp.Segment, sz int32) (Controller_dev_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Controller_dev_Results](l), err
}

// Controller_dev_Results_Future is a wrapper for a Controller_dev_Results promised by a client call.
type Controller_dev_Results_Future struct{ *capnp.Future }

func (f Controller_dev_Results_Future) Struct() (Controller_dev_Results, error) {
	p, err := f.Future.Ptr()
	return Controller_dev_Results(p.Struct()), err
}
func (p Controller_dev_Results_Future) FuseFd() FileDescriptor {
	return FileDescriptor(p.Future.Field(0, nil).Client())
}

func (p Controller_dev_Results_Future) Session() DevSession {
	return DevSession(p.Future.Field(1, nil).Client())
}

type ShellFDs capnp.Struct

// ShellFDs_TypeID is the unique identifier for the type ShellFDs.
const ShellFDs_TypeID = 0xa58abe200abe0444

func NewShellFDs(s *capnp.Segment) (ShellFDs, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ShellFDs(st), err
}

func NewRootShellFDs(s *capnp.Segment) (ShellFDs, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return ShellFDs(st), err
}

func ReadRootShellFDs(msg *capnp.Message) (ShellFDs, error) {
	root, err := msg.Root()
	return ShellFDs(root.Struct()), err
}

func (s ShellFDs) String() string {
	str, _ := text.Marshal(0xa58abe200abe0444, capnp.Struct(s))
	return str
}

func (s ShellFDs) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (ShellFDs) DecodeFromPtr(p capnp.Ptr) ShellFDs {
	return ShellFDs(capnp.Struct{}.DecodeFromPtr(p))
}

func (s ShellFDs) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s ShellFDs) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s ShellFDs) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s ShellFDs) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s ShellFDs) AcceptHttp() FileDescriptor {
	p, _ := capnp.Struct(s).Ptr(0)
	return FileDescriptor(p.Interface().Client())
}

func (s ShellFDs) HasAcceptHttp() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s ShellFDs) SetAcceptHttp(v FileDescriptor) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s ShellFDs) AcceptSmtp() FileDescriptor {
	p, _ := capnp.Struct(s).Ptr(1)
	return FileDescriptor(p.Interface().Client())
}

func (s ShellFDs) HasAcceptSmtp() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s ShellFDs) SetAcceptSmtp(v FileDescriptor) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

func (s ShellFDs) ConnectBackend() FileDescriptor {
	p, _ := capnp.Struct(s).Ptr(2)
	return FileDescriptor(p.Interface().Client())
}

func (s ShellFDs) HasConnectBackend() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s ShellFDs) SetConnectBackend(v FileDescriptor) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(2, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().AddCap(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(2, in.ToPtr())
}

// ShellFDs_List is a list of ShellFDs.
type ShellFDs_List = capnp.StructList[ShellFDs]

// NewShellFDs creates a new list of ShellFDs.
func NewShellFDs_List(s *capnp.Segment, sz int32) (ShellFDs_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[ShellFDs](l), err
}

// ShellFDs_Future is a wrapper for a ShellFDs promised by a client call.
type ShellFDs_Future struct{ *capnp.Future }

func (f ShellFDs_Future) Struct() (ShellFDs, error) {
	p, err := f.Future.Ptr()
	return ShellFDs(p.Struct()), err
}
func (p ShellFDs_Future) AcceptHttp() FileDescriptor {
	return FileDescriptor(p.Future.Field(0, nil).Client())
}

func (p ShellFDs_Future) AcceptSmtp() FileDescriptor {
	return FileDescriptor(p.Future.Field(1, nil).Client())
}

func (p ShellFDs_Future) ConnectBackend() FileDescriptor {
	return FileDescriptor(p.Future.Field(2, nil).Client())
}

type DevSession capnp.Client

// DevSession_TypeID is the unique identifier for the type DevSession.
const DevSession_TypeID = 0xc0433f3776e7c305

func (c DevSession) UpdateManifest(ctx context.Context, params func(DevSession_updateManifest_Params) error) (DevSession_updateManifest_Results_Future, capnp.ReleaseFunc) {
	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc0433f3776e7c305,
			MethodID:      0,
			InterfaceName: "control-socket.capnp:DevSession",
			MethodName:    "updateManifest",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(DevSession_updateManifest_Params(s)) }
	}
	ans, release := capnp.Client(c).SendCall(ctx, s)
	return DevSession_updateManifest_Results_Future{Future: ans.Future()}, release
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c DevSession) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c DevSession) AddRef() DevSession {
	return DevSession(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c DevSession) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c DevSession) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c DevSession) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (DevSession) DecodeFromPtr(p capnp.Ptr) DevSession {
	return DevSession(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c DevSession) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c DevSession) IsSame(other DevSession) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c DevSession) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c DevSession) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A DevSession_Server is a DevSession with a local implementation.
type DevSession_Server interface {
	UpdateManifest(context.Context, DevSession_updateManifest) error
}

// DevSession_NewServer creates a new Server from an implementation of DevSession_Server.
func DevSession_NewServer(s DevSession_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(DevSession_Methods(nil, s), s, c)
}

// DevSession_ServerToClient creates a new Client from an implementation of DevSession_Server.
// The caller is responsible for calling Release on the returned Client.
func DevSession_ServerToClient(s DevSession_Server) DevSession {
	return DevSession(capnp.NewClient(DevSession_NewServer(s)))
}

// DevSession_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func DevSession_Methods(methods []server.Method, s DevSession_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc0433f3776e7c305,
			MethodID:      0,
			InterfaceName: "control-socket.capnp:DevSession",
			MethodName:    "updateManifest",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.UpdateManifest(ctx, DevSession_updateManifest{call})
		},
	})

	return methods
}

// DevSession_updateManifest holds the state for a server call to DevSession.updateManifest.
// See server.Call for documentation.
type DevSession_updateManifest struct {
	*server.Call
}

// Args returns the call's arguments.
func (c DevSession_updateManifest) Args() DevSession_updateManifest_Params {
	return DevSession_updateManifest_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c DevSession_updateManifest) AllocResults() (DevSession_updateManifest_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return DevSession_updateManifest_Results(r), err
}

// DevSession_List is a list of DevSession.
type DevSession_List = capnp.CapList[DevSession]

// NewDevSession creates a new list of DevSession.
func NewDevSession_List(s *capnp.Segment, sz int32) (DevSession_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[DevSession](l), err
}

type DevSession_updateManifest_Params capnp.Struct

// DevSession_updateManifest_Params_TypeID is the unique identifier for the type DevSession_updateManifest_Params.
const DevSession_updateManifest_Params_TypeID = 0xbff8c51eccea5f2d

func NewDevSession_updateManifest_Params(s *capnp.Segment) (DevSession_updateManifest_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return DevSession_updateManifest_Params(st), err
}

func NewRootDevSession_updateManifest_Params(s *capnp.Segment) (DevSession_updateManifest_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return DevSession_updateManifest_Params(st), err
}

func ReadRootDevSession_updateManifest_Params(msg *capnp.Message) (DevSession_updateManifest_Params, error) {
	root, err := msg.Root()
	return DevSession_updateManifest_Params(root.Struct()), err
}

func (s DevSession_updateManifest_Params) String() string {
	str, _ := text.Marshal(0xbff8c51eccea5f2d, capnp.Struct(s))
	return str
}

func (s DevSession_updateManifest_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (DevSession_updateManifest_Params) DecodeFromPtr(p capnp.Ptr) DevSession_updateManifest_Params {
	return DevSession_updateManifest_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s DevSession_updateManifest_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s DevSession_updateManifest_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s DevSession_updateManifest_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s DevSession_updateManifest_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// DevSession_updateManifest_Params_List is a list of DevSession_updateManifest_Params.
type DevSession_updateManifest_Params_List = capnp.StructList[DevSession_updateManifest_Params]

// NewDevSession_updateManifest_Params creates a new list of DevSession_updateManifest_Params.
func NewDevSession_updateManifest_Params_List(s *capnp.Segment, sz int32) (DevSession_updateManifest_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[DevSession_updateManifest_Params](l), err
}

// DevSession_updateManifest_Params_Future is a wrapper for a DevSession_updateManifest_Params promised by a client call.
type DevSession_updateManifest_Params_Future struct{ *capnp.Future }

func (f DevSession_updateManifest_Params_Future) Struct() (DevSession_updateManifest_Params, error) {
	p, err := f.Future.Ptr()
	return DevSession_updateManifest_Params(p.Struct()), err
}

type DevSession_updateManifest_Results capnp.Struct

// DevSession_updateManifest_Results_TypeID is the unique identifier for the type DevSession_updateManifest_Results.
const DevSession_updateManifest_Results_TypeID = 0x93f10e053f665a30

func NewDevSession_updateManifest_Results(s *capnp.Segment) (DevSession_updateManifest_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return DevSession_updateManifest_Results(st), err
}

func NewRootDevSession_updateManifest_Results(s *capnp.Segment) (DevSession_updateManifest_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return DevSession_updateManifest_Results(st), err
}

func ReadRootDevSession_updateManifest_Results(msg *capnp.Message) (DevSession_updateManifest_Results, error) {
	root, err := msg.Root()
	return DevSession_updateManifest_Results(root.Struct()), err
}

func (s DevSession_updateManifest_Results) String() string {
	str, _ := text.Marshal(0x93f10e053f665a30, capnp.Struct(s))
	return str
}

func (s DevSession_updateManifest_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (DevSession_updateManifest_Results) DecodeFromPtr(p capnp.Ptr) DevSession_updateManifest_Results {
	return DevSession_updateManifest_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s DevSession_updateManifest_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s DevSession_updateManifest_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s DevSession_updateManifest_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s DevSession_updateManifest_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// DevSession_updateManifest_Results_List is a list of DevSession_updateManifest_Results.
type DevSession_updateManifest_Results_List = capnp.StructList[DevSession_updateManifest_Results]

// NewDevSession_updateManifest_Results creates a new list of DevSession_updateManifest_Results.
func NewDevSession_updateManifest_Results_List(s *capnp.Segment, sz int32) (DevSession_updateManifest_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[DevSession_updateManifest_Results](l), err
}

// DevSession_updateManifest_Results_Future is a wrapper for a DevSession_updateManifest_Results promised by a client call.
type DevSession_updateManifest_Results_Future struct{ *capnp.Future }

func (f DevSession_updateManifest_Results_Future) Struct() (DevSession_updateManifest_Results, error) {
	p, err := f.Future.Ptr()
	return DevSession_updateManifest_Results(p.Struct()), err
}

type FileDescriptor capnp.Client

// FileDescriptor_TypeID is the unique identifier for the type FileDescriptor.
const FileDescriptor_TypeID = 0xd9ccfac7d7a20cc0

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c FileDescriptor) String() string {
	return fmt.Sprintf("%T(%v)", c, capnp.Client(c))
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c FileDescriptor) AddRef() FileDescriptor {
	return FileDescriptor(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c FileDescriptor) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c FileDescriptor) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c FileDescriptor) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (FileDescriptor) DecodeFromPtr(p capnp.Ptr) FileDescriptor {
	return FileDescriptor(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c FileDescriptor) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c FileDescriptor) IsSame(other FileDescriptor) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c FileDescriptor) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c FileDescriptor) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
} // A FileDescriptor_Server is a FileDescriptor with a local implementation.
type FileDescriptor_Server interface {
}

// FileDescriptor_NewServer creates a new Server from an implementation of FileDescriptor_Server.
func FileDescriptor_NewServer(s FileDescriptor_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(FileDescriptor_Methods(nil, s), s, c)
}

// FileDescriptor_ServerToClient creates a new Client from an implementation of FileDescriptor_Server.
// The caller is responsible for calling Release on the returned Client.
func FileDescriptor_ServerToClient(s FileDescriptor_Server) FileDescriptor {
	return FileDescriptor(capnp.NewClient(FileDescriptor_NewServer(s)))
}

// FileDescriptor_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func FileDescriptor_Methods(methods []server.Method, s FileDescriptor_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 0)
	}

	return methods
}

// FileDescriptor_List is a list of FileDescriptor.
type FileDescriptor_List = capnp.CapList[FileDescriptor]

// NewFileDescriptor creates a new list of FileDescriptor.
func NewFileDescriptor_List(s *capnp.Segment, sz int32) (FileDescriptor_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[FileDescriptor](l), err
}

const schema_d4c5feffbd79e908 = "x\xda\x8c\x94]h\x1cU\x14\xc7\xcf\xb9\x1fNZ\x12" +
	"\xe9e\x12D\xc4&\x8d\x81\x1a0_\xc6b\xad\x0f\x13" +
	"\xd2m\xd4\xd2\xe2\xdcn\x0b\xb2 f\x9c\xbda\x97\xce" +
	"\xce\x8e{\xef\xae\xb4 \xad\x82\x14\xfa\xa0\xa8\x0f\x0a\xbe" +
	"\x89\xd2\x07+\x05\xc1\x17\xc1\x9a\"\xa5(\xf5E\x0a\xe2" +
	"[\x11D\xf4\xcd\xfa\x81\xfa\xe0\x95\xbb\xdb\xc9N\xda$" +
	"\xe4a`\xb8\xe7\x9c\xff9\xe7w\xcf\xb9\xb3?\xe1\x02" +
	"\x9b\x1b\x0a< \xf28\xbf\xc7\xceVV\x02~\xefo" +
	"\xef\x80\x18C\x00\xe6\x01\xcc\xbfN?G`\xf6\xc9\xb7" +
	"w^\xf8x\xf5\xec\xbb\x05K\x9b\xbe\xe6,%vy" +
	"\xe7\xd8\xe5\xf3\x1f\x81\x18A;\xf0\xcb\xa9/\xec\x7fW" +
	"o\x00\xa7\x1e\x80\x1f\xd1[~\xa3\xfbW\xa7\x97\x00\xed" +
	"\xf2\xbe\x0b\xb53\x0f\xbdy\xa9\xa7\xc2\xd1\xc9\x0c\xb1\x0a" +
	"\x02\xfa\xf7\xb3\x00\xd0N\xbd\xf0\xeb\xf5\xddW\xff\xfe\xb2" +
	"\x90\xe6\x09\xf6\xa9K\xc3\xbf\xfa\xb9\xf3xpp\x15\xc4" +
	"\x08\xed\xa7\x01\x9c\x9fd\x04\xfd}\xce\xd5\x9fcO\xf9" +
	"\xcf\xbb?\xbbg\xf7?\xe3W.\xbe\xf1\xf5\xedD\xc4" +
	"\x09\x1db\xe7]\xa2\x13\xece@\xfb\xc9\x91g\xb3\xfd" +
	"o\xed\xfd\xee.\xb9\xcf\x9c\xdc\x15v\x1f\x80\xff-;" +
	"\xe7\xef\xe1N\xee\x81\xf0\x9b?\xf7\x9a\x0fo\x14\xe5v" +
	"\xf0\x17\x9d\xdc\x08wr\xab\x83\x1f|\x7f\xed\xdf\xeb?" +
	"\xdc%\xf7\x12\x1fG\xffU'\xe2\xbf\xc2=\xf7\x01\xd8" +
	"\x1f\xffz\xff\\\xfb\xf7k7A\x8c\xb1~%\x80\xf3" +
	"\x8aW\xd0?\xe5|\xca\x86S,\x9f\xe5\x04!\xb5q" +
	"35\xadf2\xc5u3>\xa9\xcct\x1ceiv" +
	"\xa0\xa4:e\xa5u\xbd\x99N\xb7\xb3jd\xd4\xd1(" +
	"\xad\xaf(m&\x8e\x05J\xb7\x13\xa3\xd7\x02\x07\xd6\x05" +
	"\x1e\xec\x9d&\xaa5]U\x9drM%\xc9D\x18\xb5" +
	"\xa2\x86\x86<`\x9d\x7f\xb9\xa6F\x93d\xa9\xa4CD" +
	"9H\x19\x00C\x00q\xa8\x02 K\x14eHP " +
	"\x0e\xa3;<\xea\x0e\x8fP\x94\xcf\x11\x14\x84\x0c#\x01" +
	"\x10'N\x03\xc8\xe3\x14\xe52A\x1b\xc5\xb1\xca\xcc\xd3" +
	"\x06\xa8\xc9P\xf4\xc9\x01\xa2\x80\xdc\\nlb\x8e\x9b" +
	"i\xaab\xb3\x08A\x14\x9fTiuc\x97n\x0fl" +
	"\x8b\xa6\xbb\xfd\xd2\x86\x96l\xad\x9d\xa1G\x01\xe4\x00E" +
	"9Lp4\xca\xb2g\xaa8\x08\x04\x07\x0b\x8a\xdb\xe5" +
	"\x1f\x8evi\xae\xc5\xd1M\xe2\xc0\x01e\x94\x03\xac\x0d" +
	">\xe6+(\xc4i b\x87gsm\x08z\xea\x0b" +
	"\x18\xe2f%mt\xb3\xc7z\xb3\xd0m.\xefu\xf2" +
	"0\x80|\x98\xa2|\xacpus\x07\x00\xe4#\x14\xe5" +
	"~\x82V\xbb\xd8\xa5\xaa\x06\x00\xdc\xd5\xdfq@\xdc\x05" +
	"\x18\xd4\xa2\xb4\x9a(\x14\xf6\xe6\xe2\xf2\xf2\xc5\x89?\xde" +
	"\xbb\x93=\xdd\xa4,\x90\x0c\xb10\xffX\xb1=\xcf0" +
	"\x02jjr\xa0\x0b#\x7fl0_c1w\x18\x88" +
	"\x98\xf4\xb0\xff\x84`\xbe\x93\xe2\xc1q Bx6\xef" +
	"\x18\x00\x16\xd0\xab\xaa\xcezR[\x8e\x83\x83\xe4%F" +
	"\x17\x199\x1c\x13\x14\xe5l\x81\xd1\xd4b\x1f\\\xb0\xd2" +
	"\xd6ji\x83\x09<\xa3{\xd7\x8b\xa2\xffjm\xc9g" +
	"\xa9\x9e\xa8\x92\xd2q\xab\x9ey\xa6\xd9\x0a\x11C\xca\xb7" +
	"U{\x0e\x8f\x9aZ\x88x{`A\xe0-;\xd3\x89" +
	"Z3:JIU\x9bf\xab1\xd3\xf3\x9c\x89\x9b\xa3" +
	"\xdd\xe0\xff\x03\x00\x00\xff\xff\x8d\xa5\xd1_"

func init() {
	schemas.Register(schema_d4c5feffbd79e908,
		0x93f10e053f665a30,
		0x9780c0aba70a923b,
		0xa58abe200abe0444,
		0xaf8f237f68a73560,
		0xbff8c51eccea5f2d,
		0xc0433f3776e7c305,
		0xc98eacc122f91e21,
		0xd2279138704f4cad,
		0xd4a47427f5ca501b,
		0xd9ccfac7d7a20cc0,
		0xe0c7f375879bf6e2)
}
